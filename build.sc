import mill.define.{Module, TaskModule}
import mill.eval.PathRef
import mill.scalalib._
import mill.scalalib.publish._

/** Build JARs. */
def _build() = T.command {
  core.jar()
}

/** Run tests. */
def test(millExe: String = "mill") = T.command {
  core.test.test()()
  integrationTest.test(millExe)()
}

def install() = T.command {
  T.ctx().log.info("Installing")
  test()()
  core.publishLocal()()
}

/** Test and release to Maven Central. */
def release(
  sonatypeCreds: String,
  release: Boolean = true
) = T.command {
  test()()
  core.publish(sonatypeCreds = sonatypeCreds, release = release)()
}

trait MillOsgiModule extends ScalaModule with PublishModule {

  def scalaVersion = T{ "2.12.8" }

  def ivyDeps = T { Agg(ivy"org.scala-lang:scala-library:${scalaVersion()}") }

  def publishVersion = GitSupport.publishVersion()._2

  object Deps {
    val ammonite = ivy"com.lihaoyi:::ammonite:1.3.2"
    val bndlib = ivy"biz.aQute.bnd:biz.aQute.bndlib:4.0.0"
    val logbackClassic = ivy"ch.qos.logback:logback-classic:1.1.3"
    val millMain = ivy"com.lihaoyi::mill-main:0.3.5"
    val millScalalib = ivy"com.lihaoyi::mill-scalalib:0.3.5"
    val scalaTest = ivy"org.scalatest::scalatest:3.0.1"
    val slf4j = ivy"org.slf4j:slf4j-api:1.7.25"
  }

  def javacOptions = Seq("-source", "1.8", "-target", "1.8")

  def pomSettings = T {
    PomSettings(
      description = "Mill module adding OSGi bundle support",
      organization = "de.tototec",
      url = "https://github.com/lefou/mill-osgi",
      licenses = Seq(License.`Apache-2.0`),
      versionControl = VersionControl.github("lefou", "mill-osgi"),
      developers = Seq(Developer("lefou", "Tobias Roeser", "https.//github.com/lefou"))
    )
  }

}

object core extends MillOsgiModule {

  override def artifactName = "de.tobiasroeser.mill.osgi"

  def ivyDeps = T {
    super.ivyDeps() ++ Agg(
      Deps.bndlib,
      Deps.slf4j
    )
  }

  def compileIvyDeps = Agg(
    Deps.millMain,
    Deps.millScalalib
  )

  object test extends Tests {

    override def ivyDeps = Agg(
      Deps.scalaTest
    )
    def testFrameworks = Seq("org.scalatest.tools.Framework")

  }

}

object testsupport extends MillOsgiModule {

  def compileIvyDeps = Agg(
    Deps.millMain,
    Deps.millScalalib
  )

  override def artifactName = "mill-osgi-testsupport"

  override def moduleDeps = Seq(core)
}

/**
 * Integration tests for the mill module.
 * You can provide new test cases by placing a project into `src/${NR}-${TESTNAME}`.
 * Those project files will be copied into a temporary test directory.
 * Then `mill` will run the `_verify` task, which should do all the test verification and fail, in case of a test failure.
 * To import the mill-osgi plug-in into your build, you can import the generated `plugin.sc` file.
 * Example:
 * {{{
 * // plugin-specific imports, generated by integration test infra
 * import $exec.plugin
 * }}}
 */
object integrationTest extends TaskModule {

  def defaultCommandName = "test"

  /** Provide the test cases */
  def testCases = T.input {
    val src = millSourcePath / 'src
    os.list(src).filter(_.toIO.isDirectory()).map(PathRef(_))
  }

  /** Run the tests. */
  def test(millExe: String = "mill") = T.command {
    import os._

    // trigger published artifact
    core.publishLocal()()
    val coreArtifact = core.artifactMetadata()

    testsupport.publishLocal()()
    val testSupportArtifact = testsupport.artifactMetadata()

    val pluginImport =
      s"""// Import a locally published version of the plugin under test
         |import $$ivy.`${coreArtifact.group}:${coreArtifact.id}:${coreArtifact.version}`
         |import $$ivy.`${testSupportArtifact.group}:${testSupportArtifact.id}:${testSupportArtifact.version}`
       """.stripMargin

    val tests = testCases()
    os.makeDir.all(T.ctx().dest)

    case class TestCase(name: String, exitCode: Int, out: Seq[String], err: Seq[String]) {
      override def toString(): String =
        s"Test case: ${
          name
        }\nExit code: ${
          exitCode
        }\n\n[out]\n\n${
          out.mkString("\n")
        }\n\n[err]\n\n${
          err.mkString("\n")
        }"

    }

    val results = tests.map { t =>
      val testPath = T.ctx().dest / t.path.last
      T.ctx().log.info("Running integration test: " + t.path.last)

      // start clean
      remove.all(testPath)

      // copy test project here
      copy(from = t.path, to = testPath, createFolders = true)

      // create plugin classpath file
      write(testPath / "plugin.sc", pluginImport)

      // run mill with _verify target in test path
      // -i ensures, we do not spawn a mill-worker process
      val result = proc(millExe, "-i", "verify").call(cwd = testPath, check = false)
      if(result.exitCode == 0) {
        T.ctx().log.info("Finished integration test: " + t.path.last)
      } else {
        T.ctx().log.error("Failed integration test: " + t.path.last)
      }
      TestCase(t.path.last, result.exitCode, result.out.lines, result.err.lines)
    }

    val (succeeded, failed) = results.partition(_.exitCode == 0)

    println(s"\nSucceeded integration tests: ${succeeded.size}\n${succeeded.mkString("\n", "\n", "")}")
    println(s"\nFailed integration tests: ${failed.size}\n${failed.mkString("\n", "\n", "")}")

    T.ctx().log.info(s"Integration tests: ${tests.size}, ${succeeded.size} succeeded, ${failed.size} failed")

    if (!failed.isEmpty) throw new AssertionError(s"${failed.size} integration test(s) failed")

  }

}

object GitSupport extends Module {

  /**
   * The current git revision.
   */
  def gitHead = T.input {
    sys.env.get("TRAVIS_COMMIT").getOrElse(
      os.proc('git, "rev-parse", "HEAD").call().out.trim
    )
  }

  /**
   * Calc a publishable version based on git tags and dirty state.
   *
   * @return A tuple of (the latest tag, the calculated version string)
   */
  def publishVersion = T.input {
    val tag =
      try Option(
        os.proc('git, 'describe, "--exact-match", "--tags", "--always", gitHead()).call().out.trim
      )
      catch {
        case e => None
      }

    val dirtySuffix = os.proc('git, 'diff).call().out.string.trim() match {
      case "" => ""
      case s => "-DIRTY" + Integer.toHexString(s.hashCode)
    }

    tag match {
      case Some(t) => (t, t)
      case None =>
        val latestTaggedVersion = os.proc('git, 'describe, "--abbrev=0", "--always", "--tags").call().out.trim

        val commitsSinceLastTag =
          os.proc('git, "rev-list", gitHead(), "--not", latestTaggedVersion, "--count").call().out.trim.toInt

        (latestTaggedVersion, s"$latestTaggedVersion-$commitsSinceLastTag-${gitHead().take(6)}$dirtySuffix")
    }
  }

}