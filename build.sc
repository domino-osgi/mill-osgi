import mill.define.Module
import mill.scalalib._
import mill.scalalib.publish._

/** Build JARs. */
def _build() = T.command {
  core.jar()
}

/** Run tests. */
def _test(millExe: String = "mill") = T.command {
  core.test.test()()
  integrationTest.test(millExe)()
}

def _install() = T.command {
  T.ctx().log.info("Installing")
  _test()()
  core.publishLocal()()
}

/** Test and release to Maven Central. */
def _release(
  sonatypeCreds: String,
  release: Boolean = true
) = T.command {
  _test()()
  core.publish(sonatypeCreds = sonatypeCreds, release = release)()
}

trait MillOsgiModule extends ScalaModule with PublishModule {

  def scalaVersion = "2.12.7"

  def ivyDeps = T { Agg(ivy"org.scala-lang:scala-library:${scalaVersion()}") }

  def publishVersion = "0.0.4-SNAPSHOT"

  object Deps {
    val bndlib = ivy"biz.aQute.bnd:biz.aQute.bndlib:4.0.0"
    val logbackClassic = ivy"ch.qos.logback:logback-classic:1.1.3"
    val millMain = ivy"com.lihaoyi::mill-main:0.3.2"
    val millScalalib = ivy"com.lihaoyi::mill-scalalib:0.3.2"
    val scalaTest = ivy"org.scalatest::scalatest:3.0.1"
    val slf4j = ivy"org.slf4j:slf4j-api:1.7.25"
  }

  def javacOptions = Seq("-source", "1.8", "-target", "1.8")

  def pomSettings = T {
    PomSettings(
      description = "Mill module adding OSGi bundle support",
      organization = "de.tototec",
      url = "https://github.com/lefou/mill-osgi",
      licenses = Seq(License.`Apache-2.0`),
      versionControl = VersionControl.github("lefou", "mill-osgi"),
      developers = Seq(Developer("lefou", "Tobias Roeser", "https.//github.com/lefou"))
    )
  }

}

object core extends MillOsgiModule {

  override def artifactName = "de.tobiasroeser.mill.osgi"

  def ivyDeps = T {
    super.ivyDeps() ++ Agg(
      Deps.bndlib,
      Deps.slf4j
    )
  }

  def compileIvyDeps = Agg(
    Deps.millMain,
    Deps.millScalalib
  )

  object test extends Tests {

    override def ivyDeps = Agg(
      Deps.scalaTest
    )
    def testFrameworks = Seq("org.scalatest.tools.Framework")

  }

}

object testsupport extends MillOsgiModule {

  def compileIvyDeps = Agg(
    Deps.millMain,
    Deps.millScalalib
  )

  override def artifactName = "mill-osgi-testsupport"

  override def moduleDeps = Seq(core)
}

import ammonite.ops._

/**
 * Integration tests for the mill module.
 * You can provide new test cases by placing a project into `src/${NR}-${TESTNAME}`.
 * Those project files will be copied into a temporary test directory.
 * Then `mill` will run the `_verify` task, which should do all the test verification and fail, in case of a test failure.
 * To import the mill-osgi plug-in into your build, you can import the generated `plugin.sc` file.
 * Example:
 * {{{
 * // plugin-specific imports, generated by integration test infra
 * import $exec.plugin
 * }}}
 */
object integrationTest extends Module {

  /** Provide the test cases */
  def testCases = T.input {
    val src = millSourcePath / 'src
    ls(src).filter(_.isDir).map(PathRef(_))
  }

  /** Run the tests. */
  def test(millExe: String = "mill") = T.command {
    val tests = testCases()
    mkdir(T.ctx().dest)

    def resolve(name: String): Path = {
      core.runClasspath().find(pr =>
        pr.path.last.startsWith(name)).get.path
    }

    val libs = Seq(
      core.jar().path -> "mill-osgi.jar",
      testsupport.jar().path -> "mill-osgi-testsupport.jar",
      resolve("slf4j-api-") -> "slf4j-api.jar",
      resolve("biz.aQute.bndlib-") -> "bndlib.jar"
    )

    val libPath = T.ctx().dest / 'lib
    mkdir(libPath)
    libs.foreach { lib =>
      // copy plugin here
      cp(lib._1, libPath / lib._2)
    }

    case class TestCase(name: String, exitCode: Int, out: Seq[String], err: Seq[String]) {
      override def toString(): String =
        s"Test case: ${
          name
        }\nExit code: ${
          exitCode
        }\n\n[out]\n\n${
          out.mkString("\n")
        }\n\n[err]\n\n${
          err.mkString("\n")
        }"

    }

    val results = tests.map { t =>
      val testPath = T.ctx().dest / t.path.last
      T.ctx().log.info("Running integration test: " + t.path.last)

      // start clean
      rm(testPath)

      // copy test project here
      cp(t.path, testPath)

      // create plugin classpath file
      write(testPath / "plugin.sc", libs.map(lib =>
        "import $cp.^.lib.`" + lib._2 + "`\n"))

      // run mill with _verify target in test path
      val result = try {
        %%(millExe, "_verify")(testPath)
      } catch {
        case e: ShelloutException => e.result
      }

      TestCase(t.path.last, result.exitCode, result.out.lines, result.err.lines)
    }

    val (succeeded, failed) = results.partition(_.exitCode == 0)

    println(s"\nSucceeded integration tests: ${succeeded.size}\n${succeeded.mkString("\n", "\n", "")}")
    println(s"\nFailed integration tests: ${failed.size}\n${failed.mkString("\n", "\n", "")}")

    if (!failed.isEmpty) throw new AssertionError(s"${failed.size} integration test(s) failed")

  }

}
